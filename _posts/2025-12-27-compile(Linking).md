---
title: "Compile(Linking)"
excerpt: "컴파일 과정 중 링킹에 대해서 다룹니다."

categories:
  - Compile
tags:
  - [Compile, Linking]

permalink: /Compile/linking

toc: true
toc_sticky: true

date: 2025-12-28
last_modified_at: 2025-12-28
---

## 링킹(Linking)
***
링킹과정은 크게 다음과 같습니다.
   
- 심볼 해석, 참조 정의 매핑
- 섹션 병합/배치, 최종 주소 결정
- relocation을 통해 코드/데이터를 ABI규칙에 따라 패치, 실행 가능 바이너리 완성
   
이를 통한 목적은 크게 두 가지로 나뉩니다.
   
- 서로 다른 번역 단위(translation unit)에서 발생한 심볼 참조(symbol reference)를 정의(definition)에 연결
- 코드/데이터를 최종 레이아웃으로 배치, 기계어 내부의 주소 필드를 재배치(relocation)로 패치, 실행 가능 바이너리로 완성
   
링킹에서의 입력/출력 아티펙트
   
#### 입력
   
- 오브젝트 파일 : 각 소스 파일이 컴파일/어셈블된 결과. 섹션과 심볼, relocation 정보를 포함
- 정적 라이브러리 : 여러 오브젝트 파일의 묶음(아카이브)
- 공유 라이브러리 : 런타임 로더가 적재할 수 있는 동적 로딩 대상
   
#### 출력
   
- 실행 파일(ELF/PE 등) : 코드/데이터 섹션 + 엔트리 포인트 + 로더 정보
- 공유 라이브러리(ELF .so, PE . dll 등) : 동적 로딩/심볼 내보내기(export) 메타 데이터 포함
- 링크 맵/심볼 맵 : 레이아웃/심볼 주소 추적용

##### 용어 정리

- 섹션 : 컴파일러/어셈블러가 생성한 논리 조각(.text, .rodata, .data, .bss 등)
- 세그먼트 : 로더가 메모리에 매핑하는 단위(RX 코드, R 읽기전용 데이터, RW 데이터)
   
> 링커는 섹션들을 합쳐 세그먼트로 재구성, 메모리에 어떤 보호 속성으로 배치될지에 대해서도 반영합니다.
   
- 정의 심볼(defined) : 해당 오브젝트가 실제로 제공하는 함수/전역 데이터
- 미해결 심볼(undefined) : 외부에서 반드시 제공되어야 하는 참조
- 가시성/바인딩 : 외부로 노출되는지(링크 가능 범위), 강한/약한 정의(weak/strong) 같은 결합 규칙
- 재배치 : 기계어/데이터 내 이 위치에 이후 주소를 채워 넣어야 한다는 내용 표기(링커가 최종 주소 확정 후 해당 위치를 패치합니다)
   
### 링커 처리 파이프라인
   
> 심볼 해석(Symbol Resolution - 라이브러리 선택(정적 라이브러리의 경우) - 레이아웃(Layout) 결정 - 재배치 적용(Relocation Fixups)
   
#### 심볼 해석(Symbol Resolution)
   
모든 입력을 스캔하여 각 심볼을 누가 정의하는가에 대한 결정을 내립니다.
   
이 단계에서 발생할 수 있는 오류는 다음과 같습니다.
   
- undefined reference 계열 오류
참조는 있는데 정의가 어디에도 없는 경우
- multiple definition 계열 오류
동일한 강한 정의가 두 곳 이상 존재하는 경우
   
C++ 사용 시 빈번한 원인으로 보이는 케이스는 다음과 같습니다.
   
- 헤더에 전역 변수 정의(int g;를 헤더에 두고 여러 cpp에서 include하는 경우)
- 템플릿/인라인 정의가 링크 시점에 필요한 번역 단위에 존재하지 않는 경우
- 라이브러리/오브젝트 링크 순서 문제(주로 정적 라이브러리에서)
   
위의 케이스에서는 ODR 위반이 확인됩니다.

#### 라이브러리 선택(정적 라이브러리의 경우)
   
정적 라이브러리는 오브젝트의 묶음이기에 링커가 보통 현재까지 미해결인 심볼을 해결해줄 수 있는 멤버 오브젝트만 라이브러리에 꺼내 포함시키는 특성을 지닙니다. 
이 특성으로 인하여 다음의 문제가 발생하게 됩니다.
   
- 라이브러리가 너무 이른 시점에 처리되는 경우, 필요성을 인지하지 못하여 멤버를 꺼내지 않기에 링크가 실패하게 되는 경우
- 순환 의존(라이브러리 A가 B를, B가 A를 요구)에서 순서/반복 스캔 옵션이 필요하게 되는 경우
   
#### 레이아웃(Layout) 결정
   
심볼 소유권이 정해진 후, 링커는 섹션들을 하나로 합치고 배치하게 되며 그 과정은 다음과 같습니다.   
   
1. 여러 .text를 최종 .text로 병합합니다.
2. 여러 .rodata를 최종 .rodata로 병합합니다.
3. .data / .bss도 위 과정과 동일하게 병합을 진행합니다.
4. 정렬(Alignment) 요구사항에 맞게 패딩이 삽입됩니다.
5. 그 결과로 각 섹션의 시작 주소/오프셋이 확정되며, 각 심볼의 최종 주소가 계산됩니다.
   
이 단계에서 코드 배치가 바뀌게 되는 경우 캐시/분기 예측/페이지 지역성에 영향을 줄 수 있으며 LTO또는 함수 정렬 최적화가 성능에 관여하게 됩니다.
   
#### 재배치 적용(Relocation Fixups)
   
레이아웃으로 주소가 확정된 후, 링커는 relocation 엔트리에 따라 코드/데이터를 패치합니다.
   
해당 케이스는 다음과 같습니다.
   
- 함수 호출의 타켓 주소(혹은 상대 오프셋)
- 전역 변수 주소 참조
- vtable/RTTI 포인터, 전역 생성자 테이블 같은 런타임 메타데이터 포인터
   
패치 방식은 ABI와 ISA 규칙을 따릅니다.
   
같은 함수호출이라도 플랫폼/오브젝트 포멧/피크렐(PC-relative) 사용 여부에 따라 relocation 타입과 인코딩 규칙이 달라집니다.
   
### 정적 링크(Static Linking)와 동적 링크(Dynamic Linking)의 특징 비교
***
#### 정적 링크(Static Linking)
   
- 필요 코드가 실행 파일에 포함됩니다.
- 배포가 단순해질 수 있으나 바이너리의 크기가 증가합니다.
- 동일 라이브러리를 여러 프로세스가 각각 포함하는 경우 디스크/메모리의 중복이 일어납니다.
   
#### 동적 링크(Dynamic Linking)
   
- 실행 파일은 공유 라이브러리를 참조하며, 로더가 런타임에 적재하게됩니다.
- 간접 호출 테이블(플랫폼별 메커니즘)을 통해 실제 주소가 바인딩 될 수 있습니다.
- 보안 패치/공용 코드 공유에 유리합니다.
- 로딩 시점 비용, 심볼 바인딩/재배치 비용이 추가될 수 있습니다.
   
### 주요 발생 실패 패턴 및 진단 포인트
   
#### undefined reference
   
- 선언만 있고 정의 부재
- 라이브러리의 링크 누락
- 정적 라이브러리 링크 순서 문제
- 템플릿/인라인 정의 위치 문제
   
#### multiple definition
   
- 헤더 전역 정의 중복
- 전역 함수/전역 변수의 중복 구현
- 링커 옵션으로 COMDAT/weak 처리 예측이 실제로는 강한 정의로 되는 경우
   
#### ABI 불일치
   
- 컴파일러/표준 라이브러리/런타임 설정 불일치로 심볼 이름(맹글링) 또는 레이아웃이 변경
- 디버그/릴리즈 CRT 혼합(Windows 계열에서 빈번하게 발생)
- 호출 규약/구조체 패딩 불일치
   
### 링킹 과정 정리
***
> 심볼 해석으로 참조를 정의에 매핑 - 섹션을 병합/배치하여 최종 주소 결정 - relocation으로 코드/데이터를 ABI규칙대로 패치
   