---
title: "Library"
excerpt: "라이브러리에 대하여 다룹니다."

categories:
  - Library
tags:
  - [Library]

permalink: /Library

toc: true
toc_sticky: true

date: 2026-02-20
last_modified_at: 2026-02-20
---

## 정적 라이브러리(Static Libraries, .a)
***
   
관련된 목적 모듈(Object Modules, .o 파일)들을 하나의 아카이브(Archive) 파일로 묶은 형태입니다.
   
리눅스에서는 .o , 윈도우에서는 .lib 확장자를 가집니다.
   
아카이브로 합치는 도구에는 아카이버(Archiver, ar)가 있습니다.
   
정적 라이브러리의 장점은 다음과 같습니다.
   
- 자기 완결성
   
실행 파일 내부에 필요한 모든 코드가 포함되어 있어, 배포 시 별도의 라이브러리 파일이 요구되지 않습니다.
   
- 실행 속도
   
런타임 시 심볼 탐색 과정이 없기에 이로 실행 속도가 좀 더 빠를 수 있습니다.
   
정적 라이브러리의 단점은 다음과 같습니다.
   
- 디스크 및 메모리 낭비
   
동일 라이브러리를 사용하는 프로그램이 N개 존재 시 시스템에 동일 코드의 복사본이 N개 존재하게 됩니다.
   
- 난해한 유지보수
   
라이브러리 함수 하나만 수정한다 할지라도 이를 사용하는 모든 프로그램을 다시 컴파일, 링크해야합니다.
   
### 정적 라이브러리 활용의 정적 링킹
   
링커는 정적 라이브러리에서 필요한 모듈을 결정하기 위해서 다음의 세 가지 집합을 유지, 스캔합니다.
   
#### E (Excutable)
   
결합되어 실행 파일을 구성하게 될 목적 파일들의 집합

#### U (Unresolved symbols)
   
참조되었지만 아직 정의를 찾지 못한 심볼(함수, 변수 등)의 집합
   
#### D (Defined symbols)
   
이전 파일들에서 이미 정의된 심볼들의 집합.
   
##### 정적 링킹 유의점
   
위의 스캔 과정은 명령줄에 입력된 파일 순서대로 진행되기에 라이브러리가 해당 라이브러리를 호출하는 소스 코드보다
앞에 오는 경우, 링커는 아직 필요치 않다고 판단하여 무시하게되고 undefined reference 에러가 발생합니다.
   
### 공유/동적 라이브러리(Shared Libraries, .so)
   
공유/동적 라이브러리(Shared Object)는 정적 라이브러리의 단점을 해결하기 위해 고안되었습니다.
   
리눅스에서는 .so , 윈도우에서는 .dll 확장자를 가집니다.
   
동작 방식(Load/Run-time Linking)은 다음과 같습니다.
   
- 정적 라이브러리와 다르게 실행 파일 내부에 코드 복사가 없음. 
- 라이브러리가 로드되어야 한다는 정보, 심볼 테이블을 실행 파일 내부에 포함.
- 실제 결합은 프로그램 메모리 로드(Load-time), 실행 중(Run-time)에 발생
   
공유/동적 라이브러리는 위치 독립적 코드(PIC, Position-Independent Code)라는 점이 주요 메커니즘에 해당합니다.
   
여러 실행 프로세스가 메모리 내의 동일한 라이브러리 코드 사본을 공유해야하는데 라이브러리 코드가 특정 메모리 주소에 로드되어야만
작동한다면, 서로 다른 프로세스에서 해당 주소가 이미 사용 중일 경우 공유가 불가능해집니다. 이에 대한 해결방안으로서 PIC가 고안되었습니다.
   
PIC의 구현으로 코드 세그먼트를 수정하지 않고도 라이브러리를 임의의 주소에 로드할 수 있도록 하는데
PIC 데이터 참조(PIC Data References)에서 GOT(Global Offset Table)와 PLT(Procedure Linkage Table)가 강조됩니다.
   
GOT의 역할은 다음과 같습니다.
   
- 컴파일러는 데이터 세그먼트의 시작 부분에 GOT라는 테이블을 생성
- GOT에는 프로그램이 참조하는 각 전역 데이터 객체에 대한 8바이트 주소 엔트리가 포함
- 코드 세그먼트는 전역 데이터를 직접 참조하는 대신, GOT의 특정 엔트리 참조
- 런타임에 동적 링커가 각 GOT 엔트리를 업데이트하여 데이터 객체의 실제 절대 주소를 기입
   
이를 통하여 데이터의 주소가 바뀌더라도 코드 세그먼트 자체의 수정 필요성은 없어지며 데이터 세그먼트의 GOT 테이블 값만
변경하면 되도록 함으로써 코드 세그먼트는 읽기 전용 상태로 여러 프로세스 간 공유가 가능하게 됩니다.
   
외부 함수(printf, addvec .. )를 호출하는 것은 데이터 참조보다 더 복잡하며 수천 개의 함수 주소를 프로그램 시작 시점에 모두 계산하는 것은 비효율적이기에
해결 방안으로 지연 바인딩(Lazy Binding)이 도입됩니다. 이 지연 바인딩의 사용을 위해 PLT(Procedure Linkage Table)이 요구됩니다.

PLT는 코드 세그먼트에 위치한 배열로, 각 엔트리는 특정 함수를 호출하는 작은 코드조각(stub), 입구에 해당합니다.
   
코드는 수정될 수 없으므로 PLT의 각 엔트리 주소는 실행 파일 내에서 고정되어 있습니다.
   
각 함수(ex. addvec)는 자신만의 PLT 엔트리(PLT[2] 등)를 가집니다.
   
지연 바인딩은 공유 라이브러리의 함수를 호출 시, 프로그램이 실행되는 시점(Load-time)이 아닌
그 함수가 실제로 처음 호출되는 시점(Run-time)에 해당 함수의 주소를 찾아 연결하는 형태입니다.
   
프로그램이 수십의 라이브러리, 라이브러리 내에는 수천의 함수를 포함하는 경우 프로그램 실행 시 모든 함수의 주소를 찾아 연결하는 경우
시간적 측면의 자원손해가 너무 크기에 실제 사용 전까지 주소를 찾지 않는 것이 지연 바인딩의 주 개념입니다.
   
예시로 addvec 호출이 되는 경우를 기준으로 지연 바인딩의 실행 과정을 확인함으로써 PLT의 역할을 알 수 있습니다.
   
- 최초 호출(The First Call) 시 주소 찾기 단계
   
1. 제어권 전이
   
사용자 프로그램이 addvec를 호출 시, 실행 파일 내부의 고정 주소인 addvec@plt로 점프합니다. 해당 주소는 컴파일 시점에 결정된 PIC 주소입니다.
2. GOT 첫 번째 참조
   
addvec@plt 내부의 첫 번째 명령어는 GOT[addvec]에 저장된 주소로 점프입니다.
   
초기 상태에서 GOT[addvec]에는 addvec의 실제 주소가 없으며, PLT 내부의 다음 명령어 주소가 기록되어 있습니다.
3. 링커 호출 준비
   
점프했다가 바로 다음 줄로 돌아온 PLT 코드는 addvec을 식별하는 ID(Relocation Offset)를 스택에 넣고 모든 PLT의 공통 입구인 PLT[0]로 점프합니다.
4. 동적 링커 실행
   
PLT[0]은 동적 링커를 호출하고 링커는 공유 라이브러리 파일에서 addvec의 실제 메모리 주소를 계산합니다.
5. GOT 업데이트
링커는 계산된 실제 주소를 데이터 영역인 GOT[addvec] 엔트리에 써넣으며 바인딩이 완료됩니다.
   
- 이후 호출(Subsequent Calls) 시 직접 점프 단계
   
직접 점프에서는 이미 주소를 알고 있기에 링커를 부르는 낭비가 없게 됩니다.
   
1. 제어권 전이
   
다시 addvec@plt로 점프합니다.
2. GOT 두 번째 참조
   
addvec@plt는 다시 GOT[addvec]에 적힌 주소로 점프하라는 명령을 실행합니다.
3. 직접 점프
   
이번에는 GOT[addvec]에 실제 addvec의 주소가 적혀 있으며 PLT의 나머지 코드를 거치지 않고 곧바로 함수의 실제 위치로 넘어갑니다.
   
이를 통해 addvec이 실제로 호출되는 순간까지 주소 해석을 미루게 되며 런타임에 찾아낸 주소를 GOT에 기록하여 고정시키기에
지연 바인딩이라 하게 됩니다.

지연 바인딩의 과정에서 PLT는 함수 호출을 가로채서 주소를 연결해주는 로직이 담긴 코드에 해당합니다.
   
PIC는 보안적 측면에서 ASLR(Address Space Layout Randomization)의 기반이 됩니다.
   
ASLR은 공격자가 함수의 절대 주소를 예측, 악성 코드를 실행하는 것을 막기 위해 스택, 힙, 공유/동적 라이브러리 영역의 주소를
실행할  때마다 난수화하는 보안 기술입니다.
   
PIC는 절대 주소 대신 PC-상대 참조(PC-relative reference)와 GOT를 사용함으로써 데이터 세그먼트의 GOT 테이블 값만 런타임 업데이트가 필요하도록 구성하고
코드를 수정 없이(Read-only) 유지하고 정확한 주소 탐색을 가능하도록 합니다.
   
ASLR은 주소 난수화를 통한 보안, 코드 공유를 이용한 효율성을 PIC를 기반으로 하여 얻을 수 있습니다.
   
지연 바인딩의 특성으로 라이브러리 인터포지셔닝에 대해서 알아볼 수 있습니다.
   
#### 라이브러리 인터포지셔닝(Library Interpositioning)
   
라이브러리 인터포지셔닝은 공유/동적 라이브러리 함수(ex. malloc, free)에 대한 호출을 가로채서 사용자가 정의한
래퍼(Wrapper) 함수를 대신 실행하도록 만드는 기법입니다. 이를 통하여 함수의 인자와 반환값을 추적하거나, 실행 시간을 측정하고 
접근 권한을 제한하는 등의 동작을 수행할 수 있습니다.
   
라이브러리 인터포지셔닝은 발생 시점에 따라 다음의 세 가지 방식으로 분류됩니다.
   
1. 컴파일 타임 인터포지셔닝(Compile-time)
   
구현이 간단한 것이 장점이며, C 전처리기를 사용하여 소스 코드 수준에서 함수 이름을 바꾸는 방식입니다.
   
#define malloc(size) mymalloc(size)와 같은 매크로를 포함한 헤더 파일을 사용하여 컴파일합니다.
   
그러나 모든 소스 코드를 다시 컴파일해야하고 이미 빌드된 바이너리에는 적용이 불가능한 단점이 있습니다.
   
2. 링크 타임 인터포지셔닝(Link-time)
   
소스 코드를 수정할 필요 없이 목적 파일(.o)만 있으면 가능한 것이 장점이며 정적 링커의 심볼 해석 규칙을 이용합니다.
   
\리눅스 링커(ld)의 --wrap f 플래그를 사용합니다. 링커는 f에 대한 참조를 __wrap_F로 해석하고 원래의 f는 __real_f라는 이름으로 호출할 수 있게 해줍니다. 
   
3. 런타임 인터포지셔닝(Run-time)
   
동적 링커의 로딩 순서를 조작합니다. 가장 강력하며 널리 쓰이는 방식에 해당합니다.
   
LD_PRELOAD 환경 변수를 사용합니다. 동적 링커는 프로그램을 실행할 때 표준 라이브러리보다
LD_PRELOAD에 명시된 라이브러리를 먼저 검색합니다.
실행 예시는 다음과 같습니다.
   
```C
LD_PRELOAD="./mymalloc.so" ./intr
```
   
작동 원리는 다음과 같습니다.
   
- 프로그램이 malloc을 호출하려고 PLT/GOT 메커니즘을 가동합니다.
- 동적 링커는 주소를 찾을 때 LD_PRELOAD에 있는 라이브러리를 먼저 확인합니다.
- 사용자가 만든 malloc이 발견될 시 그 주소를 GOT에 등록합니다.
- 표준 malloc 대신 사용자의 malloc이 실행됩니다.