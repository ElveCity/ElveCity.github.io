---
title: "컴파일"
excerpt: "전체 과정"

categories:
  - Compile
tags:
  - [Complie]

permalink: /Complie/

toc: true
toc_sticky: true

date: 2025-12-22
last_modified_at: 2025-12-24
---

# 컴파일에 관하여

### 전체 과정
   
> 전처리(Preprocessing) - 컴파일(Compilation) - 어셈블(Assembly) - 링크(Linking)
   
## 전처리(Preprocessing)
   
\#include, #define, #if같은 전처리 지시문에 해당하는 것들을 변환합니다.
컴파일러의 개입 이전에 텍스트로 재구성하는 단계이고 의미 해석, 타입 검사, 링크는 없습니다.   
전처리 단계에서는 플랫폼, 빌드 옵션, 디버그/릴리즈, 에디터/런타임과 같은 차이를 소스 코드 수준에서
정리합니다. 이를 통해 다른 실행 환경에서 쉽게 변경하고 컴파일 할 수 있도록 합니다.   

##### #include
   
해당 파일의 내용을 현재 위치에 그대로 복사해서 붙여 넣는 것을 의미합니다.   

> \#include "NewHeader.h   
이는 다음과 같습니다.   
> NewHeader.h의 전체 내용 텍스트   

같은 헤더를 여러 번 include시 그 내용도 여러번 복사되며 
이를 막기 위해 incldue guard(매크로 기반, 표준C++)와 #pragma once(파일 단위 기반, 비표준이나 거의 지원)를 사용합니다.   

#### #define
   
선언이 아닌 치환규칙입니다.
> \#define SIZE 10
   
이의 전처리 결과는 다음과 같습니다.
      
> int arr[SIZE]; // int arr[10];
   
SIZE라는 토큰을 10이라는 문자열로 치환하라는 규칙입니다.   

#### \#if
   
전처리 시점에서 소스 코드의 일부를 존재하지 않게 만들거나 포함시키는 조건부 컴파일에 해당합니다.
   
	#if DEBUG
		Log();
	#endif
   
위와 같은 코드에서 DEBUG가 정의되어 있지 않은 경우 전처리 결과로 아무것도 없는 상태가 나옵니다.
   
	#if (debug)
	{	
		Log();
	}
   
위 코드에서 debug == false가 나오는 경우 실행만 불가능한 상태로 분기 명령, 명령 캐시 사용, 코드 크기 증가와도 같은
비용은 그대로 존재하게 됩니다.
   
## 컴파일(Compilation)
   
텍스트로 된 소스 코드를 링크 가능한 목적 파일(.o , .obj)로 변환합니다.
목적 파일에는 기계어와 후에 링크 단계에서 필요한 심볼(symbol)정보와 재배치(relocation)정보 또한 포함됩니다.
   
심볼은 이 함수/변수의 이름, 정의 위치, 외부 참조 여부를 확인하는데 사용되고 
재배치는 후에 실제 주소가 결정되었을 때 이 기계어의 이 위치를 수정해야한다라는 패치포인트를 아는데 사용됩니다.
   
이 단계에서는 주소가 확정되지 않습니다. 프로세스가 실제로 로드되는 때의 최종 주소는 아직 모르는 상태로 진행됩니다.
   
컴파일러가 소스 코드를 읽을 때의 과정은 다음과 같습니다.
   
### 구문 분석(Syntax analysis)

- 가장 앞단에서 렉서(lexer)가 문자 흐름을 토큰(token)으로 쪼갭니다.
   
	int sum(int a, int b)
	{
	return a + b;
	}
   
\위와 같은 코드가 들어오는 경우
	int, sum, (, int, a, , , ... 와 같은 단위로 분해됩니다.
   
- 파서(parser)가 토큰열을 이용해 문법 규칙에 맞는 트리 구조를 생성합니다.
   보통 이 결과를 파스 트리(parse tree)라 합니다.
- 파스 트리에서 불필요한 문법 요소를 줄이고 의미 중심으로 만든 것을 AST(Abstract Syntax Tree)라 합니다.
   AST는 컴파일러가 이후 단계에서 이 코드가 무엇을 할 것인지 계산하기 좋은 형태로 만든 설계도에 해당합니다.
   

### 의미 분석 (sementic analysis)
   
이 단계에서 수행하는 작업은 크게 두 가지로 나뉩니다.
   
- 코드가 문법적으로 맞는지 체크
   
\변수 사용 시 선언 유무, 변수 타입, 함수 호출 시의 인자 개수/타입, 접근 제어 가능 여부와 같은 것을 이 작업에서 확인합니다.
   
- 심볼 테이블(symbol table) 구축
   
심볼 테이블은 다음과 같은 정보를 포함합니다.
   
> 각 심볼이 무엇인지(함수/전역/지역/정적), 타입, 저장위치, 외부링크 가능여부(링키지), 섹션 배치 스타일과 같은 메타데이터
\
   
### IR(Intermediate Representation) 변환과 최적화
   
AST상태에서 기계어로 만드는 사이에 중간과정으로 IR변환을 통해서 여러 최적화 패스를 적용합니다.
   
최적화 패스에는 다음과 같은 것들이 포함됩니다.
   
> 상수 전파(constant propagation), 공통 부분식 제거(CSE), 죽은 코드 제거(DCE), 인라이닝(inlining), 루프 변환(언롤링, 벡터화 가능성 탐색) 등..
   
상기의 최적화는 프로그램의 의미는 유지하며 더 빠르고/작은 형태를 만들기 위한 단계입니다.
   
최적화가 진행될수록 소스 코드의 형태와 최종 기계어의 형태는 꽤나 달라질 수 있습니다.
   
이로 인해서 디버깅 빌드와 릴리즈 빌드에서 동작 경로나 스택 프레임이 다르게 보일 수 있는 현상이 발생합니다.
   
### 코드 생성(Codegen)
   
이 단계에서는 타겟 아키텍처(x86-64, ARM64 etc..)에 맞는 명령을 선택, 레지스터 할당(register allocation),
스택 프레임 설계, 호출 규약에 적합한 인자 전달/리턴 규칙 처리를 행합니다.
   
이 결과는 어셈블리 또는 오브젝트 코드(기계어 바이트)로 나오게 됩니다.
   
대다수의 툴체인에서는 컴파일러는 어셈블리를 산출하고, 어셈블러가 이를 활용하여 목적 파일을 만드는 흐름으로 구성됩니다.
   
#### 목적 파일 내부 환경
   
목적 파일은 대개 여러 섹션으로 나누어지며 몇몇 섹션별로 포함되는 정보는 다음과 같습니다.
   
> .text
   
텍스트 형태의 코드

> .data
   
초기값이 있는 전역/정적 데이터
   
> .bss
   
0으로 초기화되는 전역, 정적 데이터
   
> .rodata
   
상수 문자열 같은 읽기 전용 데이터
   
이외의 섹션들도 존재합니다.
      
   
목적 파일에서는 섹션별 정보에서 프로세스 로드 시 최종 주소를 알 수 없습니다.
   
printf를 호출 한 경우 printf의 정의는 보통 다른 라이브러리에 있어 기계어 내에 printf로 점프하라는 명령이 들어가야 하지만
컴파일 시점에 printf의 실제 주소가 확정되어 있지 않는 경우가 이에 해당합니다.
   
링크 단계에서 실제 주소를 채우게 되는데 이를 위하여 컴파일러/어셈블러는 심볼(symbol)과 재배치(relocation) 두 가지를 목적파일에 생성합니다.

##### 심볼(Symbol)
   
목적 파일에는 정의한 심볼(defined symbols)과 참조하지만 여기에는 정의가 없는 심볼(undefined symbols)이 함께 기록됩니다.
   
setImmune()을 정의했으면 setImmune은 define, printOutput를 호출만 했으면 printOutput은 undefined로 기록됩니다.
   
외부 공개 여부 또한 심볼에 포함되는 정보입니다.
   
C/C++의 경우 static 전역 함수/변수는 보통 파일 내부에서만 보이기 때문에 외부로 보내지 않도록 내부 링키지 형태로 처리되며 
extern이나 일반 전역 함수의 경우 외부에서 링크가 가능하도록 외부 링키지 형태로 처리됩니다.
   
이를 통해서 링크 단계에서 다른 오브젝트의 심볼 사용 가능 여부를 결정하게 됩니다.
   
##### 재배치(Relocation)
   
주소가 정해진 후 기계어의 어느 바이트를 변경해야 한다를 기록한 패치 포인트 목록입니다.
   
x86-64에서 어떤 외부 함수로 call을 건다고 할 때, 명령 인코딩 안에는 보통 "현재 위치로부터의 상태 오프셋"이 들어가게 되는데, 
이 오프셋은 링크가 최종 배치를 정해야 계산이 가능합니다.
   
컴파일러/어셈블러는 일단 0이나 임시값을 써두고 해당 위치에 "이 위치는 printf 심볼을 기준으로 relocation을 적용해야 한다"라는 내용을 기록하게 됩니다.
   
링커는 여러 목적 파일과 라이브러리를 한데 모으면서 각 섹션의 최종 배치 주소를 결정하고, 심볼의 최종 주소를 계산한 뒤, 
relocation 테이블을 보며 해당 위치의 기계어 값을 정확한 값으로 패치하여 완전히 주소가 확정된 실행 코드가 결과로 나오게 됩니다.
   
> 정리
   
소스의 목적 파일로의 변경을 진행하면서 문법/의미 검증, IR 기반 최적화, 기계어 조각과 섹션 구성, 링크 단계를 고려한 심볼 테이블, relocation정보의 구성이 
컴파일 단계의 주요 처리 내용에 해당합니다.
   