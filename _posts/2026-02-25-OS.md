---
title: "Operating System"
excerpt: "운영체제에 대하여 다룹니다."

categories:
  - Operating System
tags:
  - [Operating System]

permalink: /Operating System

toc: true
toc_sticky: true

date: 2026-02-25
last_modified_at: 2026-02-25
---

# 운영체제(Operating System)
***
   
운영체제는 디스크 위의 명령어, 데이터의 뭉치라고 할 수 있는 바이트들을 읽고 실행함으로써 프로그램을 유용한 무언가로 변환하는 역할을 수행하는 것이 운영체제입니다.
   
## 운영체제에서의 용어 및 해당 개념
   
- 프로세스(Process)
   
운영체제가 제공하는 가장 근본적 추상화입니다. 실행중인 프로그램이라고 정의하기도 합니다.
   
디스크에 저장되어 있는 경우 활동이 없는 명령어, 데이터의 뭉치인 프로그램으로 존재하나
운영체제가 이를 메모리에 올리고 실행함으로써 활동하는 프로세스로 변환합니다. 특정 시점의 프로세스는
메모리(주소공간), 레지스터(PC, 스택 포인터 등), I/O상태와 같은 머신 상태를 통해 요약될 수 있습니다.
   
- CPU 가상화와 시분할(CPU Virtualization & Time Sharing)
   
운영체제는 실제 물리적 CPU가 적더라도 사용자에게 CPU가 무한이 많은 것 같은 환상을 제공합니다.
이를 CPU 가상화라 칭합니다. CPU 가상화라는 환상을 구현하는 핵심 기술은 시분할이며 하나의 자원을
여러 프로세스가 조금씩 번갈아 가며 사용하게 하여 동시에 실행되는 것처럼 보이게 합니다.
   
CPU를 공유해야 하기에 각 프로세스의 실행 속도가 다소 느려질 수 있다는 성능상의 비용이 발생하게 됩니다.
   
- 공간 분할(Space Sharing)
   
시분할의 대응 개념입니다. 자원을 시간적으로 나누는 것이 아닌 물리적인 공간으로 나누어 할당하는 방식입니다.
예시로 디스크가 그에 해당하는데 특정 데이터 블록이 한 파일에 할당되는 경우 사용자가 해당 파일을 삭제하기 
전까지는 다른 파일에 할당되지 않고 그 공간을 독점적으로 사용하는 형태의 상황이 발생합니다.
   
- 프로세스 API(Process API)
   
운영체제는 프로세스를 관리하기 위해 표준화된 인터페이스를 제공합니다.
   
새로운 프로세스르르 만드는 생성(Create), 강제로 프로세스를 멈추는 파괴(Destroy), 
프로세스가 끝날 때까지 기다리는 대기(Wait), 실행 중인 프로세스를 잠시 멈추거나 재개하는
제어(Mincellaneous Control) 및 상태 확인(Status)기능이 포함되어 있습니다.
   
- 프로세스 로딩(Process Loading: Eager, Lazy)
   
프로그램이 실행되려면 디스크에 있는 코드와 데이터를 메모리의 주소 공간으로 읽어들이는 '로딩'과정이 
필요합니다. 초기 OS는 실행 전 모든 데이터를 한꺼번에 메모리에 올리는 조급한(Eager) 로딩 방식을 썼고
현대 OS는 실제 실행 중에 필요한 부분만 그때그때 가져오는 지연(Lazy) 로딩 방식을 주로 사용합니다.
   
- 스택과 힙(Stack & Heap)
   
프로세스 실행을 위해 운영체제가 할당하는 두 가지 주요 메모리 영역으로 스택(Stack)과 힙(Heap)이 
있습니다. 스택은 지역변수, 함수 매개변수, 리턴 주소 등을 관리하며 운영체제에 의해 자동으로 초기화됩니다.
힙은 malloc()과 같은 함수를 통해 사용자가 명시적으로 요청하는 동적 데이터 구조(리스트, 트리 등)를 
위해 사용되며, 프로그램의 필요에 따라 크기가 늘어날 수 있습니다.

- 프로세스 상태 (Process States)
   
프로세스는 크게 세 가지 상태를 오가며 실행됩니다. 실제로 명령어를 수행 중인 실행(Running), 
실행될 준비는 되었지만 OS가 아직 CPU를 할당하지 않은 준비(Ready), I/O 요청 등으로 인해 
특정 이벤트가 완료될 때까지 실행될 수 없는 차단(Blocked) 상태가 있습니다. 
   
OS 스케줄러는 정책에 따라 프로세스를 준비에서 실행으로(스케줄), 혹은 실행에서 준비로(비스케줄) 
전환하며 시스템을 운영합니다.
   
- 자원 활용과 I/O 중첩(Resource Utilization & I/O Overlapping)
   
운영체제는 시스템의 자원을 효율적으로 사용하기 위해 한 프로세스가 I/O 작업을 시작하여 
차단(Blocked) 상태가 되면, 즉시 다른 프로세스를 실행하여 CPU가 바삐 동작하도록 유지합니다. 
이를 통해 시스템의 전반적인 자원활용도를 높이게 됩니다.
   
I/O가 완료되었을 때 즉시 해당 프로세스로 돌아갈 지, 현재 실행중인 프로세스를 계속 실행할지에 
대해서는 운영체제의 스케줄러가 판단해야하며 복잡한 문제에 해당합니다.
   
- 데이터 구조와 프로세스 리스트(PCB & Process List)
   
OS는 수많은 프로세스의 관리를 위해 내부적으로 프로세스 리스트 또는 테스크 리스트라는 데이터 구조를 
유지합니다. 각 프로세스에 대한 상세 정보는 프로세스 제어 블록(Process Control Block, PCB) 
이라 불리는 구조체에 저장됩니다. 
   
여기에는 프로세스의 상태뿐만 아니라 레지스터 정보 등 프로세스를 다시 가동하는데 필요한 데이터 또한 이 구조체에 포함됩니다.
   
- 레지스터 컨텍스트와 컨텍스트 스위치(Register Context & Context Switch)
   
프로세스가 실행을 멈췄을 때, 그 시점의 CPU 레지스터 값들은 메모리의 특정 위치(레지스터 컨텍스트)에 
안전하게 저장됩니다. 나중에 운영체제가 이 프로세스를 다시 실행하기로 결정하면, 저장해 두었던 
값들을 실제 물리 레지스터에 복원, 멈춘 적이 없는 것처럼 실행 재개가 가능하게 되며 이를 컨텍스트 스위치라 합니다.
   
- xv6 구조체(xv6 proc Structure)
   
현실적인 운영체제(xv6)의 예시를 보면, 프로세스를 관리하기 위해 프로세스 ID(PID), 
부모 프로세스 포인터, 열린 파일 목록, 그리고 커널 스택 위치 등 방대한 정보를 추적합니다.
   
이러한 구조체는 프로세스가 어떤 메모리 영역을 사용하는지(mem), 현재 어떤 상태인지(state)를 
실시간으로 기록하여 OS가 정밀한 제어를 할 수 있게 합니다.
   
- 좀비 상태와 프로세스 생명 주기(Zombie State & Lifecycle)
   
프로세스는 실행, 준비, 차단 외에도 생성 중인 초기 상태와 실행이 끝났지만 아직 완전히 정리되지 않은 
최종 상태를 가집니다. 유닉스 기반 시스템에서는 이를 좀비 상태라 칭하는데 이는 부모 프로세스가 
자식의 종료 코드(성공 여부)를 확인할 수 있도록 최소한의 정보를 남겨둔 상태입니다.
   
부모 프로세스가 wait() 호출을 통해 이를 확인하고 나면 OS는 해당 프로세스의 모든 데이터 구조를
메모리에서 제거합니다.
   
- 스케줄링 정책의 세부 설정(Scheduling Policy Flags)
   
스케줄링의 세부 규칙에 따라 시스템의 성능은 크게 편차가 발생하게 됩니다. 
예를 들어 I/O 작업 시 즉시 다른 프로세스로 전환할지(SWITCH_ON IO) 아니면 
끝날 때까지 기다릴지(SWITCH_ON_END) 아니면 나중에 실행할지(IO_RUN_LATER) 등을 설정할 수 있습니다. 
   
이러한 설정값들은 시스템 자원의 유효활용과 응답성 사이의 균형을 맞출 때 상당히 중요합니다.
   
## UNIX 프로세스 API
   
### 프로세스 API 용어
   
- fork()
   
시스템 콜은 UNIX 시스템에서 새로운 프로세스를 생성하는데 사용됩니다.
생성자는 부모, 새로 생성된 프로세스는 자식이라고 불립니다. 자식 프로세스는 부모의 거의 동일한 복사본에 해당합니다.
   
- wait()
   
시스템 콜은 부모가 자식의 실행이 완료될 때까지 기다릴 수 있게 해줍니다.
   
- exec()
   
시스템 콜은 자식이 부모와의 유사성에서 벗어나 완전히 새로운 프로그램을 실행할 수 있게 해줍니다.
   
### 시스템 인터페이스의 유연성, 확장성
   
- 결합과 분리
   
fork()와 exec()가 분리되어 설계되었기에, 프로세스 생성과 실행 사이에 셸(Shell)이 개입하여
환경을 조작할 수 있는 유연성이 생깁니다.
   
- 자원 리디렉션
   
파일 기술자 관리 규칙을 이용해 프로그램 수정 없이 입출력 경로를 파일이나 파이프로 변경할 수 있습니다.
   
### 운영체제 수준의 보호와 제어
   
- 비결정론적 스케줄링
   
CPU 스케줄러에 의해 프로세스 실행 순서가 결정되므로 실행 순서의 불확실성을 늘 고려해야 합니다.
   
- 신호와 권한 제어
   
신호(signal)를 통해 외부 이벤트를 전달하고, 사용자(user)와 슈퍼유저(root) 권한을 통해
프로세스 제어 범위를 엄격히 제한하여 시스템의 안정성을 보장합니다.
   
### UNIX 프로세스 API 생성, 제어 및 변환 메커니즘
   
- fork() 시스템 콜, 프로세스 생성
   
UNIX 시스템에서 새로운 프로세스를 생성하는 가장 기본적인 수단입니다. 호출한 프로세스(부모)의 거의 정확한 복사본인 
자식 프로세스를 만들어냅니다. 자식 프로세스는 프로그램의 처음(main)부터 시작하지 않고 fork() 호출 시점부터 바로 실행을 
이어가며, 부모는 자식의 PID를 반환받고 자식은 0을 반환받음으로써 서로의 역할을 구분합니다.
   
- wait() 시스템 콜을 통한 동기화
   
wait()는 부모 프로세스가 자신이 생성한 자식 프로세스의 작업이 완료될 때까지 실행을 일시적으로 중단(block)
하는 데 사용됩니다. 이 시스템 콜은 자식이 종료될 때까지 반환되지 않으므로, 부모와 자식간의 실행 순서를
확실히 제어하여 프로그램의 출력 결과가 항상 일정하게 나오도록 만드는 동작을 가능하게 합니다.
   
- exec() 시스템 콜과 프로세스 변환
   
exec() 계열의 함수는 현재 실행 중인 프로세스를 완전히 새로운 프로그램으로 변환시키는 역할을 수행합니다. 
새로운 프로세스를 추가로 만드는 것이 아니라, 기존 프로세스의 메모리(코드, 스택, 힙)를 
새로운 프로그램의 데이터로 덮어씌워 재초기화하는 방식이기 때문에, 
성공적으로 호출될 경우 원래의 코드로 다시 돌아오지 않습니다.
   
- fork()와 exec() 분리의 중요성
   
UNIX 설계의 핵심은 프로세스 생성(fork)과 프로그램 실행(exec)을 분리한 것에 있으며,
이는 셸(Shell)이 자식 생성 후 실제 프로그램 실행 전 사이의 짧은 시간 동안 코드를 실행할 수 있게 해줍니다.
   
셸은 이 사이에 입출력 리디렉션이나 파이프 설정 같은 환경 조작을 수행할 수 있어 이를 기반으로 
실행될 프로그램 자체를 수정하지 않고도 다양한 기능을 구현할 수 있는 유연성을 제공합니다.
   
- 파일 기술자(File Descriptor)와 리디렉션 원리
   
리디렉션은 UNIX가 가장 낮은 번호의 빈 기술자부터 할당한다는 가정을 활용합니다. 
셸은 자식 프로세스에서 표준 출력(STDOUT_FILENO)를 닫고 특정 파일을 열어 그 파일에 출력 번호를 
가로채게 만든 뒤 exec()를 호출하며, 이렇게 열린 파일 기술자는
프로그램 변환 후에도 유지되므로 투명한 입출력 제어가 가능해집니다.
   
- 사용자 권한과 슈퍼유저(Root) 개념
   
운영체제는 시스템의 보안과 공정한 자원 분배를 위해 사용자라는 개념을 도입, 
각자가 자신의 프로세스만 제어할 수 있도록 제한합니다. 
   
슈퍼유저인 root는 다른 사용자의 프로세스를 강제 종료하거나 시스템 전체에 영향을 주는 
강력한 명령을 내릴 수 있는 예외적인 권한을 가지나, 그만큼 위험성이 크기에 신중히 관리해야합니다.
   
- CPU 스케줄러와 비결정론적 실행
   
운영체제의 CPU 스케줄러는 복잡한 알고리즘에 따라 어떤 프로세스를 언제 실행할지 결정하므로, 
fork() 이후 부모와 자식 중 누가 먼저 실행될지는 미리 예측할 수 없습니다.
   
이러한 실행 순서의 불확실성을 비결정론(Non-determinism)이라 하며, 
이는 멀티스레드 환경 등에서 여러 문제를 야기합니다.
   

