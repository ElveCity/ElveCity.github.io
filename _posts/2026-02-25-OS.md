---
title: "Operating System"
excerpt: "운영체제에 대하여 다룹니다."

categories:
  - Operating System
tags:
  - [Operating System]

permalink: /Operating System

toc: true
toc_sticky: true

date: 2026-02-25
last_modified_at: 2026-02-25
---

# 운영체제(Operating System)
***
   
운영체제는 디스크 위의 명령어, 데이터의 뭉치라고 할 수 있는 바이트들을 읽고 실행함으로써 프로그램을 유용한 무언가로 변환하는 역할을 수행하는 것이 운영체제입니다.
   
## 운영체제에서의 용어 및 해당 개념
   
- 프로세스(Process)
   
운영체제가 제공하는 가장 근본적 추상화입니다. 실행중인 프로그램이라고 정의하기도 합니다.
   
디스크에 저장되어 있는 경우 활동이 없는 명령어, 데이터의 뭉치인 프로그램으로 존재하나
운영체제가 이를 메모리에 올리고 실행함으로써 활동하는 프로세스로 변환합니다. 특정 시점의 프로세스는
메모리(주소공간), 레지스터(PC, 스택 포인터 등), I/O상태와 같은 머신 상태를 통해 요약될 수 있습니다.
   
- CPU 가상화와 시분할(CPU Virtualization & Time Sharing)
   
운영체제는 실제 물리적 CPU가 적더라도 사용자에게 CPU가 무한이 많은 것 같은 환상을 제공합니다.
이를 CPU 가상화라 칭합니다. CPU 가상화라는 환상을 구현하는 핵심 기술은 시분할이며 하나의 자원을
여러 프로세스가 조금씩 번갈아 가며 사용하게 하여 동시에 실행되는 것처럼 보이게 합니다.
   
CPU를 공유해야 하기에 각 프로세스의 실행 속도가 다소 느려질 수 있다는 성능상의 비용이 발생하게 됩니다.
   
- 공간 분할(Space Sharing)
   
시분할의 대응 개념입니다. 자원을 시간적으로 나누는 것이 아닌 물리적인 공간으로 나누어 할당하는 방식입니다.
예시로 디스크가 그에 해당하는데 특정 데이터 블록이 한 파일에 할당되는 경우 사용자가 해당 파일을 삭제하기 
전까지는 다른 파일에 할당되지 않고 그 공간을 독점적으로 사용하는 형태의 상황이 발생합니다.
   
- 프로세스 API(Process API)
   
운영체제는 프로세스를 관리하기 위해 표준화된 인터페이스를 제공합니다.
   
새로운 프로세스르르 만드는 생성(Create), 강제로 프로세스를 멈추는 파괴(Destroy), 
프로세스가 끝날 때까지 기다리는 대기(Wait), 실행 중인 프로세스를 잠시 멈추거나 재개하는
제어(Mincellaneous Control) 및 상태 확인(Status)기능이 포함되어 있습니다.
   
- 프로세스 로딩(Process Loading: Eager, Lazy)
   
프로그램이 실행되려면 디스크에 있는 코드와 데이터를 메모리의 주소 공간으로 읽어들이는 '로딩'과정이 
필요합니다. 초기 OS는 실행 전 모든 데이터를 한꺼번에 메모리에 올리는 조급한(Eager) 로딩 방식을 썼고
현대 OS는 실제 실행 중에 필요한 부분만 그때그때 가져오는 지연(Lazy) 로딩 방식을 주로 사용합니다.
   
- 스택과 힙(Stack & Heap)
   
프로세스 실행을 위해 운영체제가 할당하는 두 가지 주요 메모리 영역으로 스택(Stack)과 힙(Heap)이 
있습니다. 스택은 지역변수, 함수 매개변수, 리턴 주소 등을 관리하며 운영체제에 의해 자동으로 초기화됩니다.
힙은 malloc()과 같은 함수를 통해 사용자가 명시적으로 요청하는 동적 데이터 구조(리스트, 트리 등)를 
위해 사용되며, 프로그램의 필요에 따라 크기가 늘어날 수 있습니다.

- 프로세스 상태 (Process States)
   
프로세스는 크게 세 가지 상태를 오가며 실행됩니다. 실제로 명령어를 수행 중인 실행(Running), 
실행될 준비는 되었지만 OS가 아직 CPU를 할당하지 않은 준비(Ready), I/O 요청 등으로 인해 
특정 이벤트가 완료될 때까지 실행될 수 없는 차단(Blocked) 상태가 있습니다. 
   
OS 스케줄러는 정책에 따라 프로세스를 준비에서 실행으로(스케줄), 혹은 실행에서 준비로(비스케줄) 
전환하며 시스템을 운영합니다.
   
- 자원 활용과 I/O 중첩(Resource Utilization & I/O Overlapping)
   
운영체제는 시스템의 자원을 효율적으로 사용하기 위해 한 프로세스가 I/O 작업을 시작하여 
차단(Blocked) 상태가 되면, 즉시 다른 프로세스를 실행하여 CPU가 바삐 동작하도록 유지합니다. 
이를 통해 시스템의 전반적인 자원활용도를 높이게 됩니다.
   
I/O가 완료되었을 때 즉시 해당 프로세스로 돌아갈 지, 현재 실행중인 프로세스를 계속 실행할지에 
대해서는 운영체제의 스케줄러가 판단해야하며 복잡한 문제에 해당합니다.
   
- 데이터 구조와 프로세스 리스트(PCB & Process List)
   
OS는 수많은 프로세스의 관리를 위해 내부적으로 프로세스 리스트 또는 테스크 리스트라는 데이터 구조를 
유지합니다. 각 프로세스에 대한 상세 정보는 프로세스 제어 블록(Process Control Block, PCB) 
이라 불리는 구조체에 저장됩니다. 
   
여기에는 프로세스의 상태뿐만 아니라 레지스터 정보 등 프로세스를 다시 가동하는데 필요한 데이터 또한 이 구조체에 포함됩니다.
   
- 레지스터 컨텍스트와 컨텍스트 스위치(Register Context & Context Switch)
   
프로세스가 실행을 멈췄을 때, 그 시점의 CPU 레지스터 값들은 메모리의 특정 위치(레지스터 컨텍스트)에 
안전하게 저장됩니다. 나중에 운영체제가 이 프로세스를 다시 실행하기로 결정하면, 저장해 두었던 
값들을 실제 물리 레지스터에 복원, 멈춘 적이 없는 것처럼 실행 재개가 가능하게 되며 이를 컨텍스트 스위치라 합니다.
   
- xv6 구조체(xv6 proc Structure)
   
현실적인 운영체제(xv6)의 예시를 보면, 프로세스를 관리하기 위해 프로세스 ID(PID), 
부모 프로세스 포인터, 열린 파일 목록, 그리고 커널 스택 위치 등 방대한 정보를 추적합니다.
   
이러한 구조체는 프로세스가 어떤 메모리 영역을 사용하는지(mem), 현재 어떤 상태인지(state)를 
실시간으로 기록하여 OS가 정밀한 제어를 할 수 있게 합니다.
   
- 좀비 상태와 프로세스 생명 주기(Zombie State & Lifecycle)
   
프로세스는 실행, 준비, 차단 외에도 생성 중인 초기 상태와 실행이 끝났지만 아직 완전히 정리되지 않은 
최종 상태를 가집니다. 유닉스 기반 시스템에서는 이를 좀비 상태라 칭하는데 이는 부모 프로세스가 
자식의 종료 코드(성공 여부)를 확인할 수 있도록 최소한의 정보를 남겨둔 상태입니다.
   
부모 프로세스가 wait() 호출을 통해 이를 확인하고 나면 OS는 해당 프로세스의 모든 데이터 구조를
메모리에서 제거합니다.
   
- 스케줄링 정책의 세부 설정(Scheduling Policy Flags)
   
스케줄링의 세부 규칙에 따라 시스템의 성능은 크게 편차가 발생하게 됩니다. 
예를 들어 I/O 작업 시 즉시 다른 프로세스로 전환할지(SWITCH_ON IO) 아니면 
끝날 때까지 기다릴지(SWITCH_ON_END) 아니면 나중에 실행할지(IO_RUN_LATER) 등을 설정할 수 있습니다. 
   
이러한 설정값들은 시스템 자원의 유효활용과 응답성 사이의 균형을 맞출 때 상당히 중요합니다.
   
