---
title: "Compile(Preprocessing ~ Assemble)"
excerpt: "전체 과정"

categories:
  - Compile
tags:
  - [Complie]

permalink: /Complie/

toc: true
toc_sticky: true

date: 2025-12-22
last_modified_at: 2025-01-10
---

# 컴파일에 관하여

## 전체 과정

> 전처리(Preprocessing) - 컴파일(Compilation) - 어셈블(Assembly) - 링크(Linking)

### 전처리(Preprocessing)

---

\#include, #define, #if같은 전처리 지시문에 해당하는 것들을 변환합니다.
컴파일러의 개입 이전에 텍스트로 재구성하는 단계이고 의미 해석, 타입 검사, 링크는 없습니다.  
전처리 단계에서는 플랫폼, 빌드 옵션, 디버그/릴리즈, 에디터/런타임과 같은 차이를 소스 코드 수준에서
정리합니다. 이를 통해 다른 실행 환경에서 쉽게 변경하고 컴파일 할 수 있도록 합니다.

##### #include

해당 파일의 내용을 현재 위치에 그대로 복사해서 붙여 넣는 것을 의미합니다.

```c++
#include "NewHeader.h
```

이는 다음과 같습니다.

```c++
NewHeader.h의 전체 내용 텍스트
```

같은 헤더를 여러 번 include시 그 내용도 여러번 복사되며
이를 막기 위해 incldue guard(매크로 기반, 표준C++)와 #pragma once(파일 단위 기반, 비표준이나 거의 지원)를 사용합니다.

#### #define

선언이 아닌 치환규칙입니다.

```c++
#define SIZE 10
```

이의 전처리 결과는 다음과 같습니다.

```c++
int arr[SIZE]; // int arr[10];
```

SIZE라는 토큰을 10이라는 문자열로 치환하라는 규칙입니다.

#### \#if

전처리 시점에서 소스 코드의 일부를 존재하지 않게 만들거나 포함시키는 조건부 컴파일에 해당합니다.

```c++
#if DEBUG
	Log();
#endif
```

위와 같은 코드에서 DEBUG가 정의되어 있지 않은 경우 전처리 결과로 아무것도 없는 상태가 나옵니다.

```c++
#if (debug)
{
	Log();
}
```

위 코드에서 debug == false가 나오는 경우 실행만 불가능한 상태로 분기 명령, 명령 캐시 사용, 코드 크기 증가와도 같은
비용은 그대로 존재하게 됩니다.

### 컴파일(Compilation)

---

텍스트로 된 소스 코드를 링크 가능한 목적 파일(.o , .obj)로 변환합니다.
목적 파일에는 기계어와 후에 링크 단계에서 필요한 심볼(symbol)정보와 재배치(relocation)정보 또한 포함됩니다.

심볼은 이 함수/변수의 이름, 정의 위치, 외부 참조 여부를 확인하는데 사용되고
재배치는 후에 실제 주소가 결정되었을 때 이 기계어의 이 위치를 수정해야한다라는 패치포인트를 아는데 사용됩니다.

이 단계에서는 주소가 확정되지 않습니다. 프로세스가 실제로 로드되는 때의 최종 주소는 아직 모르는 상태로 진행됩니다.

컴파일러가 소스 코드를 읽을 때의 과정은 다음과 같습니다.

#### 구문 분석(Syntax analysis)

- 가장 앞단에서 렉서(lexer)가 문자 흐름을 토큰(token)으로 쪼갭니다.

```c++
int sum(int a, int b)
{
return a + b;
}
```

위와 같은 코드가 들어오는 경우
int, sum, (, int, a, , , ... 와 같은 단위로 분해됩니다.

- 파서(parser)가 토큰열을 이용해 문법 규칙에 맞는 트리 구조를 생성합니다.
  보통 이 결과를 파스 트리(parse tree)라 합니다.
- 파스 트리에서 불필요한 문법 요소를 줄이고 의미 중심으로 만든 것을 AST(Abstract Syntax Tree)라 합니다.
  AST는 컴파일러가 이후 단계에서 이 코드가 무엇을 할 것인지 계산하기 좋은 형태로 만든 설계도에 해당합니다.

#### 의미 분석 (sementic analysis)

이 단계에서 수행하는 작업은 크게 두 가지로 나뉩니다.

- 코드가 문법적으로 맞는지 체크

변수 사용 시 선언 유무, 변수 타입, 함수 호출 시의 인자 개수/타입, 접근 제어 가능 여부와 같은 것을 이 작업에서 확인합니다.

- 심볼 테이블(symbol table) 구축

심볼 테이블은 다음과 같은 정보를 포함합니다.

> 각 심볼이 무엇인지(함수/전역/지역/정적), 타입, 저장위치, 외부링크 가능여부(링키지), 섹션 배치 스타일과 같은 메타데이터

#### IR(Intermediate Representation) 변환과 최적화

AST상태에서 기계어로 만드는 사이에 중간과정으로 IR변환을 통해서 여러 최적화 패스를 적용합니다.

최적화 패스에는 다음과 같은 것들이 포함됩니다.

> 상수 전파(constant propagation), 공통 부분식 제거(CSE), 죽은 코드 제거(DCE), 인라이닝(inlining), 루프 변환(언롤링, 벡터화 가능성 탐색) 등..

상기의 최적화는 프로그램의 의미는 유지하며 더 빠르고/작은 형태를 만들기 위한 단계입니다.

최적화가 진행될수록 소스 코드의 형태와 최종 기계어의 형태는 꽤나 달라질 수 있습니다.

이로 인해서 디버깅 빌드와 릴리즈 빌드에서 동작 경로나 스택 프레임이 다르게 보일 수 있는 현상이 발생합니다.

#### 코드 생성(Codegen)

이 단계에서는 타겟 아키텍처(x86-64, ARM64 etc..)에 맞는 명령을 선택, 레지스터 할당(register allocation),
스택 프레임 설계, 호출 규약에 적합한 인자 전달/리턴 규칙 처리를 행합니다.

이 결과는 어셈블리 또는 오브젝트 코드(기계어 바이트)로 나오게 됩니다.

대다수의 툴체인에서는 컴파일러는 어셈블리를 산출하고, 어셈블러가 이를 활용하여 목적 파일을 만드는 흐름으로 구성됩니다.

##### 목적 파일 내부 환경

목적 파일은 대개 여러 섹션으로 나누어지며 몇몇 섹션별로 포함되는 정보는 다음과 같습니다.

> .text

텍스트 형태의 코드

> .data

초기값이 있는 전역/정적 데이터

> .bss

0으로 초기화되는 전역, 정적 데이터

> .rodata

상수 문자열 같은 읽기 전용 데이터

이외의 섹션들도 존재합니다.

목적 파일에서는 섹션별 정보에서 프로세스 로드 시 최종 주소를 알 수 없습니다.

printf를 호출 한 경우 printf의 정의는 보통 다른 라이브러리에 있어 기계어 내에 printf로 점프하라는 명령이 들어가야 하지만
컴파일 시점에 printf의 실제 주소가 확정되어 있지 않는 경우가 이에 해당합니다.

링크 단계에서 실제 주소를 채우게 되는데 이를 위하여 컴파일러/어셈블러는 심볼(symbol)과 재배치(relocation) 두 가지를 목적파일에 생성합니다.

##### 심볼(Symbol)

목적 파일에는 정의한 심볼(defined symbols)과 참조하지만 여기에는 정의가 없는 심볼(undefined symbols)이 함께 기록됩니다.

setImmune()을 정의했으면 setImmune은 define, printOutput를 호출만 했으면 printOutput은 undefined로 기록됩니다.

외부 공개 여부 또한 심볼에 포함되는 정보입니다.

C/C++의 경우 static 전역 함수/변수는 보통 파일 내부에서만 보이기 때문에 외부로 보내지 않도록 내부 링키지 형태로 처리되며
extern이나 일반 전역 함수의 경우 외부에서 링크가 가능하도록 외부 링키지 형태로 처리됩니다.

이를 통해서 링크 단계에서 다른 오브젝트의 심볼 사용 가능 여부를 결정하게 됩니다.

##### 재배치(Relocation)

주소가 정해진 후 기계어의 어느 바이트를 변경해야 한다를 기록한 패치 포인트 목록입니다.

x86-64에서 어떤 외부 함수로 call을 건다고 할 때, 명령 인코딩 안에는 보통 "현재 위치로부터의 상태 오프셋"이 들어가게 되는데,
이 오프셋은 링크가 최종 배치를 정해야 계산이 가능합니다.

컴파일러/어셈블러는 일단 0이나 임시값을 써두고 해당 위치에 "이 위치는 printf 심볼을 기준으로 relocation을 적용해야 한다"라는 내용을 기록하게 됩니다.

링커는 여러 목적 파일과 라이브러리를 한데 모으면서 각 섹션의 최종 배치 주소를 결정하고, 심볼의 최종 주소를 계산한 뒤,
relocation 테이블을 보며 해당 위치의 기계어 값을 정확한 값으로 패치하여 완전히 주소가 확정된 실행 코드가 결과로 나오게 됩니다.

> 컴파일(Compilation)까지의 정리

소스의 목적 파일로의 변경을 진행하면서 문법/의미 검증, IR 기반 최적화, 기계어 조각과 섹션 구성, 링크 단계를 고려한 심볼 테이블, relocation정보의 구성이
컴파일 단계의 주요 처리 내용에 해당합니다.

### 어셈블(Assemble)

---

컴파일러가 만든 어셈블리(.s)를 기계어 오브젝트(.o , .obj)로 변환하는 일련의 과정입니다.

이를 통해서 텍스트 형태의 ISA(명령어 집합)표현이 실제 CPU가 실행하는 바이트열로 바뀌어 표현됩니다.

#### 어셈블 단계의 입출력

- 대표적인 입력

GNU(gcc / clang) 계열

```c++
gcc -S main.c
```

GNU 계열의 입력에서는 컴파일러 백엔드가 어셈블 단계로 넘어가기 전에 어셈블리 코드를 생성하며
\-S 옵션은 이 결과를 .s 파일로 저장하고 이후 어셈블 단계를 수행하지 않습니다.

그 결과로 file.s (AT&T 또는 intel 문법 어셈블러)이 생성됩니다.

MSVC(cl.exe) 계열

```c++
c1 / FA main.cpp
```

MSVC는 외부 어셈블러를 호출하지 않으며
컴파일러 내부에서 중간 표현(IR)과 최종 머신 코드 생성을 단일 백엔드에서 수행합니다.

/FA 옵션은 머신 코드 생성 직전 단계의 명령어 표현을 사람이 읽을 수 있는 어셈블리 형식으로 추가 출력하는 옵션입니다.

그 결과로 .asm파일이 생성됩니다.

.asm파일은 MSVC 컴파일러가 내부 코드 생성 단계에서 사용한 명령어 표현을 사람이 읽을 수 있는 어셈블리 형태로 파일에 기록한 형태에 해당합니다.

#### 어셈블리 과정

어셈블리 과정은 크게 볼 때 다음과 같습니다.

> 어셈블리 파싱(분석) - 인코딩 - 섹션/심볼 구성 - 재배치 정보 생성

##### 어셈블리 파싱

이 단계에서는 어셈블리가 한 줄 씩 문법과 지시어를 해석하며 구분 내용은 다음과 같습니다.

- 명령어 여부(mov, add, call...)
- 지시어 여부(.section, .global, .align, .byte, .long)
- 라벨 정의 여부(foo:)

명령어는 CPU가 실행할 바이트로, 지시어는 오브젝트 파일의 구조(섹션, 정렬, 심볼 속성)를 만드는 메타 명령으로 해석합니다.

##### 명령어 인코딩

이 단계에서는 텍스트가 바이트열로 변환됩니다.

x86-64에서 add rax, rbx 같은 텍스트의 경우

- opcode(연산 종류)
- operand encoding(레지스터/메모리/즉시값 구분)
- ModRM/SIB 바이트(메모리 주소 형태 표현)
- immediate/displacement(상수/오프셋)

의 형태로 각각 분해되어 실제 바이트로 인코딩 됩니다.

같은 C++ 코드여도 이 과정에서 컴파일 옵션에 따라 어셈블이 바뀌고 그 어셈블을 인코딩한 기계어도 달라지게 됩니다.

분기/점프의 경우 어디로 점프할지가 필요하기에 라벨의 위치 계산과 직결되게 됩니다.

##### 라벨/심볼 테이블 구축

어셈블 소스에는 함수 이름/전역 변수 이름/라벨이 존재하며 어셈블러가 이를 모아 심볼 테이블(Symbol Table)을 제작합니다.

심볼은 크게 두 분류로 나뉘게 됩니다.

- 정의(Definition) : 이 오브젝트 안에 실제 구현이 존재(myFunc: 라벨의 형태로 함수 몸체가 .text에 존재)
- 참조(Reference) : 여기서 사용되나 정의는 밖에 존재(call printf)

심볼 테이블이 링크 단계에서 이 이름을 실제 주소로 연결할 수 있도록 합니다.

##### 섹션 배치와 정렬

이 단계에서는 CPU 명령어 인코딩 요구사항과 ABI에서 정의한 정렬, 배치 규약에 따라 오브젝트 파일을 구성합니다.

.text, .rodata, .data, .bss와도 같은 섹션별로 데이터가 쌓이는 경우, 이를 정렬(Alignment)하는 방식에 따라 성능과 크기가 변경되며 해당되는 케이스는 다음과 같습니다.

- 특정 바이트 경계에 정렬될 때 성능/안정성이 상승되는 데이터 타입
- 브랜치 예측/캐시라인 친화를 위한 함수 시작 주소의 특정 정렬 사용
- .align 16과 같은 지시어 사용에 따른 패딩 바이트(NOP or 0)를 사용한 위치 맞춤

언리얼 엔진 5의 경우 정렬/섹션에 따라 코드 캐시(i-cache) 효율, 데이터 캐시(d- cache) 미스, 패딩 증가로 인한 바이너리 크기와 직결되는 특징이 있습니다.

##### 재배치(Relocation) 정보 생성

이 단계에서는 주소/오프셋 위치에 임시값을 넣고 링크 이후 재계산하여 덮어쓰도록 하는 relocation entry를 오브젝트 파일에 기록합니다.

오브젝트 파일 생성 시 주소/오프셋을 확정하지 못하는 경우은 다음과 같습니다.

- 다른 오브젝트/라이브러리에 있는 함수 호출(call externalFunc)
- 다른 번역 단위에 있는 전역 변수 접근
- PIC/PIE(위치 독립 코드)에서의 주소 계산

위의 경우 relocation entry를 오브젝트 파일에 기록하게 됩니다.

어셈블러는 이런 식으로 기계어에 더해 나중에 패치할 목록까지 같이 만들게 됩니다.

##### 디버그/예외 처리 메타데이터

\-g 와 같은 디버그 옵션이 켜져 있는 경우 어셈블러/툴체인이 DWARF(리눅스 계열)같은 디버그 정보를 섹션에 넣고
해당 기계어 주소의 범위는 원래 소스의 몇 번째 줄에 해당한다 와도 같은 매핑을 같이 넣습니다.

C++ 예외 처리에서는 unwind 정보(스택 되감기)와 관련된 섹션/메타데이터가 생길 수 있습니다.

###### 어셈블 단계 산출물이 링크 오류 및 성능 특성으로 직결되는 지점

> undefined reference/unsolved external 오류

해당 오류는 링크 단계에서 검출되나 원인은 어셈블 결과물에 외부 참조로 남아 있는 심볼이 존재하기에 발생하는 오류입니다.

어셈블러는 오브젝트 파일 생성 시 해당 번역 단위 내 정의되지 않은 심볼에 대해서는 오류를 발생시키지 않습니다.

오브젝트 파일 기록되는 정보는

- 해당 심볼의 외부 정의(external definition) 의존 여부
- 해당 심볼 참조 위치(offset)
- 링크 단계에서 주소의 재계산을 요구하는 재배치 엔트리(relocation entry)

따라서 이 단계에서 생성된 오브젝트 파일은 심볼 테이블과 재배치 정보 형태로 사용된 심볼의 외부 정의 정보를 작성합니다.

최종 링크 단계에서 링커가 모든 오브젝트 라이브러리를 순회하고 해당 심볼에 대한 정의(definition)를 찾지 못하는 경우
undefined reference/unsolved external 오류가 발생합니다.

> ODR 위반 / 중복 심볼 정의(multiple definition) 오류

해당 오류 또한 링크 단계에서 검출되나 어셈블 단계에서 생성된 심볼 테이블이 원인 데이터에 해당하게 됩니다.

어셈블러는 각 번역 단위를 독립적으로 처리하며 서로 다른 소스 파일에서 동일한 전역 심볼이 정의되어 있더라도

각 오브젝트 파일은 어셈블 단계에서 해당 번역 단위 내에서 실제 구현된 심볼에 대해 심볼 테이블에
정의된 심볼(defined symbol) 엔트리를 생성하고 해당 심볼이 속한 섹션과 오프셋을 함께 기록합니다.

이 시점에서는 충돌 여부를 판단할 수 없으므로 오류가 발생되지 않지만 링크 단계에서 문제가 발생하게 됩니다.

링커는 모든 오브젝트의 심볼 테이블을 병합하면서 동일한 이름의 강한 정의(strong definition)가 여러 개 존재함을 발견할 때
ODR(Ond definition Rule)위반으로 판단, multiple definition 오류를 발생시킵니다.

> 인라인/템블릿 확장으로 인한 코드 크기 증가

어셈블 단계 자체는 컴파일러 백엔드가 생성한 어셈블리 코드를 기계어로 인코딩, 오브젝트 파일에 기록하는 동작을 수행하며 코드 크기를 결정하지 않습니다.

하지만 어셈블 단계의 입력이 되는 어셈블러 코드는 인라인 함수 확장, 템플릿 인스턴스화, 헤더 기반 구현 구조에 의해 대량의 코드 중복을 포함할 수 있게 되어
.text 섹션의 크기 증가, 오브젝트 파일 및 최종 바이너리 코드 영역의 증가와도 같은 결과를 낼 수 있습니다.

이런 경우 명령어 캐시(i-cache) 점유 증가, 캐시 미스 확률 상승, 분기 예측 및 페치 효율 저하, 바이너리 크기 증가에 따른 로딩 비용 증가와 같은
성능 하락을 발생 시킬 수 있습니다.

이와 같이 어셈블 산출물의 코드 밀도와 크기는 실행 성능 특성에 직접적인 영향이 있습니다.
